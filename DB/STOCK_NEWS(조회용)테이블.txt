-- ============================================================
-- 종목별 감성 통계 SQL 
-- ============================================================

-- 1. 특정 종목의 감성 통계 
SELECT 
    STOCK_CODE,
    COUNT(*) AS TOTAL_NEWS,
    SUM(CASE WHEN SENTIMENT = '긍정' THEN 1 ELSE 0 END) AS POSITIVE_COUNT,
    SUM(CASE WHEN SENTIMENT = '부정' THEN 1 ELSE 0 END) AS NEGATIVE_COUNT,
    SUM(CASE WHEN SENTIMENT = '보통' THEN 1 ELSE 0 END) AS NEUTRAL_COUNT,
    ROUND(SUM(CASE WHEN SENTIMENT = '긍정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS POSITIVE_RATIO,
    ROUND(SUM(CASE WHEN SENTIMENT = '부정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS NEGATIVE_RATIO,
    ROUND(AVG(SCORE), 2) AS AVG_SCORE
FROM STOCK_NEWS
WHERE STOCK_CODE = :stockCode
  AND SENTIMENT IS NOT NULL
GROUP BY STOCK_CODE;

-- 2. 특정 종목의 감성 통계 
SELECT 
    STOCK_CODE,
    COUNT(*) AS TOTAL_NEWS,
    SUM(CASE WHEN SENTIMENT = '긍정' THEN 1 ELSE 0 END) AS POSITIVE_COUNT,
    SUM(CASE WHEN SENTIMENT = '부정' THEN 1 ELSE 0 END) AS NEGATIVE_COUNT,
    SUM(CASE WHEN SENTIMENT = '보통' THEN 1 ELSE 0 END) AS NEUTRAL_COUNT,
    ROUND(SUM(CASE WHEN SENTIMENT = '긍정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS POSITIVE_RATIO,
    ROUND(SUM(CASE WHEN SENTIMENT = '부정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS NEGATIVE_RATIO,
    ROUND(AVG(SCORE), 2) AS AVG_SCORE
FROM STOCK_NEWS
WHERE STOCK_CODE = :stockCode
  AND SENTIMENT IS NOT NULL
  AND NEWS_DATE >= SYSDATE - :days
GROUP BY STOCK_CODE;

-- 3. 전체 종목별 감성 통계 (대시보드용) ⚠️ 수정됨
-- 현재 구현은 STOCK_NAME을 포함하지 않지만, 필요하면 추가 가능
SELECT 
    s.STOCK_CODE,
    s.STOCK_NAME,  -- 종목명 추가 (선택사항)
    COUNT(n.NEWS_ID) AS TOTAL_NEWS,
    SUM(CASE WHEN n.SENTIMENT = '긍정' THEN 1 ELSE 0 END) AS POSITIVE_COUNT,
    SUM(CASE WHEN n.SENTIMENT = '부정' THEN 1 ELSE 0 END) AS NEGATIVE_COUNT,
    SUM(CASE WHEN n.SENTIMENT = '보통' THEN 1 ELSE 0 END) AS NEUTRAL_COUNT,
    ROUND(SUM(CASE WHEN n.SENTIMENT = '긍정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(n.NEWS_ID), 0), 2) AS POSITIVE_RATIO,
    ROUND(SUM(CASE WHEN n.SENTIMENT = '부정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(n.NEWS_ID), 0), 2) AS NEGATIVE_RATIO,
    ROUND(AVG(n.SCORE), 2) AS AVG_SCORE
FROM STOCK_INFO s
LEFT JOIN STOCK_NEWS n ON s.STOCK_CODE = n.STOCK_CODE
WHERE n.SENTIMENT IS NOT NULL
  AND n.STOCK_CODE IS NOT NULL
GROUP BY s.STOCK_CODE, s.STOCK_NAME
HAVING COUNT(n.NEWS_ID) > 0
ORDER BY TOTAL_NEWS DESC;

-- 4. 전체 종목별 감성 통계 
SELECT 
    s.STOCK_CODE,
    s.STOCK_NAME,  -- 종목명 추가 (선택사항)
    COUNT(n.NEWS_ID) AS TOTAL_NEWS,
    SUM(CASE WHEN n.SENTIMENT = '긍정' THEN 1 ELSE 0 END) AS POSITIVE_COUNT,
    SUM(CASE WHEN n.SENTIMENT = '부정' THEN 1 ELSE 0 END) AS NEGATIVE_COUNT,
    SUM(CASE WHEN n.SENTIMENT = '보통' THEN 1 ELSE 0 END) AS NEUTRAL_COUNT,
    ROUND(SUM(CASE WHEN n.SENTIMENT = '긍정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(n.NEWS_ID), 0), 2) AS POSITIVE_RATIO,
    ROUND(SUM(CASE WHEN n.SENTIMENT = '부정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(n.NEWS_ID), 0), 2) AS NEGATIVE_RATIO,
    ROUND(AVG(n.SCORE), 2) AS AVG_SCORE
FROM STOCK_INFO s
LEFT JOIN STOCK_NEWS n ON s.STOCK_CODE = n.STOCK_CODE
WHERE n.SENTIMENT IS NOT NULL
  AND n.STOCK_CODE IS NOT NULL
  AND n.NEWS_DATE >= SYSDATE - :days
GROUP BY s.STOCK_CODE, s.STOCK_NAME
HAVING COUNT(n.NEWS_ID) > 0
ORDER BY TOTAL_NEWS DESC;

-- 5. 특정 종목의 날짜별 감성 통계 
SELECT 
    TO_CHAR(NEWS_DATE, 'YYYY-MM-DD') AS NEWS_DATE,
    COUNT(*) AS TOTAL_NEWS,
    SUM(CASE WHEN SENTIMENT = '긍정' THEN 1 ELSE 0 END) AS POSITIVE_COUNT,
    SUM(CASE WHEN SENTIMENT = '부정' THEN 1 ELSE 0 END) AS NEGATIVE_COUNT,
    SUM(CASE WHEN SENTIMENT = '보통' THEN 1 ELSE 0 END) AS NEUTRAL_COUNT,
    ROUND(AVG(SCORE), 2) AS AVG_SCORE
FROM STOCK_NEWS
WHERE STOCK_CODE = :stockCode
  AND SENTIMENT IS NOT NULL
  AND NEWS_DATE >= SYSDATE - :days
GROUP BY TO_CHAR(NEWS_DATE, 'YYYY-MM-DD')
ORDER BY NEWS_DATE DESC;

-- 6. 전체 감성 통계 
SELECT 
    COUNT(*) AS TOTAL_NEWS,
    SUM(CASE WHEN SENTIMENT = '긍정' THEN 1 ELSE 0 END) AS POSITIVE_COUNT,
    SUM(CASE WHEN SENTIMENT = '부정' THEN 1 ELSE 0 END) AS NEGATIVE_COUNT,
    SUM(CASE WHEN SENTIMENT = '보통' THEN 1 ELSE 0 END) AS NEUTRAL_COUNT,
    ROUND(SUM(CASE WHEN SENTIMENT = '긍정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS POSITIVE_RATIO,
    ROUND(SUM(CASE WHEN SENTIMENT = '부정' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS NEGATIVE_RATIO,
    ROUND(SUM(CASE WHEN SENTIMENT = '보통' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS NEUTRAL_RATIO,
    ROUND(AVG(SCORE), 2) AS AVG_SCORE
FROM STOCK_NEWS
WHERE SENTIMENT IS NOT NULL;

-- 7. 종목별 키워드 TOP 10
-- 현재 구현은 Java에서 키워드를 분리/카운트하므로, 
-- SQL에서는 단순히 KEYWORDS만 조회합니다.
-- 만약 SQL에서 직접 처리하려면 아래 쿼리를 사용하세요 (복잡함)
SELECT 
    TRIM(REGEXP_SUBSTR(KEYWORDS, '[^,]+', 1, LEVEL)) AS KEYWORD,
    COUNT(*) AS KEYWORD_COUNT
FROM STOCK_NEWS
WHERE STOCK_CODE = :stockCode
  AND KEYWORDS IS NOT NULL
  AND LENGTH(TRIM(KEYWORDS)) > 0
CONNECT BY REGEXP_SUBSTR(KEYWORDS, '[^,]+', 1, LEVEL) IS NOT NULL
  AND PRIOR NEWS_ID = NEWS_ID
  AND PRIOR SYS_GUID() IS NOT NULL
GROUP BY TRIM(REGEXP_SUBSTR(KEYWORDS, '[^,]+', 1, LEVEL))
ORDER BY KEYWORD_COUNT DESC
FETCH FIRST 10 ROWS ONLY;

-- 8. 전체 키워드 TOP 20 
-- 현재 구현은 Java에서 키워드를 분리/카운트하므로,
-- SQL에서는 단순히 KEYWORDS만 조회합니다.
SELECT 
    TRIM(REGEXP_SUBSTR(KEYWORDS, '[^,]+', 1, LEVEL)) AS KEYWORD,
    COUNT(*) AS KEYWORD_COUNT
FROM STOCK_NEWS
WHERE KEYWORDS IS NOT NULL
  AND LENGTH(TRIM(KEYWORDS)) > 0
  AND NEWS_DATE >= SYSDATE - :days
CONNECT BY REGEXP_SUBSTR(KEYWORDS, '[^,]+', 1, LEVEL) IS NOT NULL
  AND PRIOR NEWS_ID = NEWS_ID
  AND PRIOR SYS_GUID() IS NOT NULL
GROUP BY TRIM(REGEXP_SUBSTR(KEYWORDS, '[^,]+', 1, LEVEL))
ORDER BY KEYWORD_COUNT DESC
FETCH FIRST 20 ROWS ONLY;

-- ============================================================
-- 유틸리티 쿼리 (데이터 확인/삭제용)
-- ============================================================

-- 전체 뉴스 조회
SELECT * FROM STOCK_NEWS ORDER BY CREATED_AT DESC;

-- STOCK_NEWS 및 STOCK_INFO 데이터 삭제 (⚠️ 주의: 모든 데이터 삭제)
ALTER TABLE STOCK_NEWS DISABLE CONSTRAINT FK_NEWS_STOCK;
TRUNCATE TABLE STOCK_NEWS;
TRUNCATE TABLE STOCK_INFO;
ALTER TABLE STOCK_NEWS ENABLE CONSTRAINT FK_NEWS_STOCK;